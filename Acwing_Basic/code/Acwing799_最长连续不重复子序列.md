# Acwing799_最长连续不重复子序列

## 思路

我们先看O(n ^ 2)的朴素做法，并从中找到单调性，从而使用双指针来降低复杂度

```cpp
//朴素做法，j是左边界，i是右边界，枚举所有可能
for(int i = 0; i < n; i++)
    for(int j = 0; j <= i; j++)
    {
        if(check(j, i))	//q[j~i]没有重复元素
            res = max(res, i - j + 1);
    }
```

所有连续不重复序列的子序列必然也是连续不重复序列，

`q[j] ~ q[i]`是以`q[i]`为结尾的最长连续不重复子序列

那么后面考虑以`q[i + 1] ~ q[n]`为结尾的最大连续不重复子序列时就不用考虑开头在`q[j]`之前

因为根据本次检查结果表明`q[j - 1] ~ q[i]`就有重复元素，一旦考虑含`q[j]`之前的元素的序列，这个含重复元素的序列就是它子序列了

所以只需要一重`for`循环遍历不同的`i`，而`j`只需要单调递增即可，`i, j`总共移动的次数为2n，即**O(n)**

```cpp
for(int i = 0, j = 0; i < n; i++)
{
    while(j <= i && check(j, i))	j++;
    
	res = max(res, j - i + 1);
}
```

### 检查`q[j] ~ q[i]`之间是否存在重复元素

我们使用一个数组`h[N]`动态调整，记录的总是当前`q[j] ~ q[i]`中各个元素值的数量，例如`h[1]`记录值为1的元素的数量

`i`是从0开始，因此每轮循环只需要进行一次`h[q[i]]++`即可使`h[N]`记录`q[0] ~ q[i]`的各元素值的数量

`j`不断向后移时，必须将原`q[j]`的元素值从`h[N]`中减去（`h[q[j]]--`），再`j++`，以保证我们动态记录的时`q[j] ~ q[i]`中各个元素值的数量

因为在上轮`q[j] ~ q[i]`是没有重复元素的序列（即`h[N]`中没有元素大于1），所以`i++`得到的新`q[j] ~ q[i]`只需要判断`h[q[i]]`是否大于`1`即可

## AC代码

```cpp
#include <iostream>
using namespace std;

const int N = 100010;

int q[N], h[N]; 
int n, res;

int main()
{
    cin >> n;
    for(int i = 0; i < n; i++)  scanf("%d", &q[i]);
    for(int i = 0, j = 0; i < n; i++)
    {
        h[q[i]]++;
        while(1 < h[q[i]]) 
        {
            h[q[j]]--;
            j++;
        }
        res = max(res, i - j + 1);
    }
    cout << res << endl;
    return 0;
}
```

