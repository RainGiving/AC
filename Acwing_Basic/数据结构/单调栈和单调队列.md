# 单调栈和单调队列

## 思路&模板

问题：给定一个数组，对每个元素，求它的左边离它最近且小于它的元素（没有满足条件的元素就输出-1）

样例：

| Input  | 3    | 4    | 2    | 7    | 5    |
| ------ | ---- | ---- | ---- | ---- | ---- |
| Output | -1   | 3    | -1   | 2    | 2    |

暴力解法：

```cpp
for(int i = 0; i < n; i++)
{
    int j = i - 1;
    for(; 0 <= j; j--)
        if(a[j] < a[i])
        {
            cout << a[j] << " ";
            break;
        }
    if(j < 0)	cout << -1 << " ";
}
```

优化：假如我们将输入的数组在求输出的过程中依次放入栈中，那么栈中如果存在`i < j && stk[j] < stk[i]`，那么`stk[i]`之后就不可能再被输出，所以通过检查可以把这些不可能输出的元素弹出，以节约时间

因此，**我们每次存入新的元素到栈中时，都要检查栈顶元素是否大于新元素，大于，则弹出，直至新栈顶小于新元素或栈为空为止；这样得到的栈必然是单调的**

```cpp
int stk[N], tt = -1;
for(int i = 0; i < n; i++)
{
    int x;	cin >> x;
    while(x <= stk[tt] && 0 <= tt)	tt--;
    if(0 <= tt)	cout << stk[tt] << " ";
    else		cout << -1 << " ";
   	stk[++tt] = a[i];
}
```

每个输入的元素只会进栈一次，出栈一次，复杂度降到了**O(n)**

## 题目&题解

[Acwing 830 单调栈](https://www.acwing.com/problem/content/832/)

[AC代码](https://github.com/RainGiving/AC/blob/master/Acwing_Basic/code/Acwing830_%E5%8D%95%E8%B0%83%E6%A0%88.cpp)

## 思路&模板

滑动窗口问题：给定一个数组，从左往右每次选取`k`个数字，求出每次选取的`k`个数的最大值和最小值

样例：该数组为 `[1 3 -1 -3 5 3 6 7]`，`k` 为 3。

| 窗口位置                   | 最小值 | 最大值 |
| :------------------------- | :----- | :----- |
| <u>[1 3 -1]</u> -3 5 3 6 7 | -1     | 3      |
| 1 <u>[3 -1 -3]</u> 5 3 6 7 | -3     | 3      |
| 1 3 <u>[-1 -3 5]</u> 3 6 7 | -3     | 5      |
| 1 3 -1 <u>[-3 5 3]</u> 6 7 | -3     | 5      |
| 1 3 -1 -3 <u>[5 3 6]</u> 7 | 3      | 6      |
| 1 3 -1 -3 5 <u>[3 6 7]</u> | 3      | 7      |

我们用队列来存储每个窗口的`k`个数字，每向后移动一次，弹出队首，插入新队尾即可

暴力做法：遍历每个窗口(**O(k)**)，一共有**O(n)**个窗口，复杂度高达**O(nk)**，`k`一般和`n`的数量级相同

优化：当我们找窗口最小值时，例如`[3, 1, -3]`，因为`-3`一定是最后才会弹出的，所以`-3`进入队列后，`3`和`1`就不可能再作为最小值输出；所以我们每次插入新队尾时，可以将队列中大于队尾的元素都弹出，这样得到的队列一定时单调递增的（找窗口最大值时同理）

```cpp
int n, k, hh, tt = -1;
int a[N], q[N];


    //这一轮循环求的是每个窗口的最小值
    for(int i = 0; i < n; i++)
    {
        //注意单调队列中存放的是当前窗口的元素索引
        //判断当前队头是否还应在窗口中（a[i]入队时的队头应在i-k+1及其后）
        if(hh <= tt && q[hh] < i - k + 1)	hh++;
        //插入新队尾前先将无效的队内元素弹出
        while(hh <= tt && a[i] <= a[q[tt]])	tt--;
        //插入新队尾
        q[++tt] = i;
        //需要完整判断第一个窗口后再输出
        if(k - 1 <= i)	printf("%d ", a[q[hh]]);
    }
```

## 题目&题解

[AcWing 154. 滑动窗口](https://www.acwing.com/problem/content/156/)

[AC代码](https://github.com/RainGiving/AC/blob/master/Acwing_Basic/code/Acwing154_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.cpp)

