# 整数二分

## 思路

这里的二分主要解决的问题是，一个序列有两种性质，分别在左右两部分，怎样找到靠左部分的边界和靠右部分的边界

![image-20210711175527195](https://raw.githubusercontent.com/RainGiving/PictureBed/master/img1/20210711175527.png)

- 当使用`mid = (l + r + 1) / 2`时，`r = l + 1`时，`mid = l + 1`，可以防止出现`[mid, r] = [l + r]`的死循环
- 当使用`mid = (l + r) / 2`时，`r = l + 1`时，`mid = l`，可以在找边界2时使用（没有`[mid, r]`这种情况）

## 模板

```cpp
bool check(int x);	// 检查x是否满足某种性质
```

### 模板1 找左边部分的边界1(`q[i] <= k`)

![image-20210711193330353](https://raw.githubusercontent.com/RainGiving/PictureBed/master/img1/20210711193330.png)

- true：左边界调整至`mid`，得到`[mid, r]`，因此要选择向上整除
- false：右边界调整至`mid - 1`，得到`[l, mid - 1]`

```cpp
int bsearch(int l, int r)
{
    while(l < r)
    {
        int mid = l + r + 1 >> 1;
        if(check(mid))	l = mid;
        else r = mid - 1;
	}
    return l;
}
```

### 模板2 找右边部分的边界2(`k <= q[i]`)

![image-20210711193437658](https://raw.githubusercontent.com/RainGiving/PictureBed/master/img1/20210711193437.png)

- true：右边界调整至`mid`，得到`[l, mid]`
- false：左边界调整至`mid + 1`，得到`[mid + 1, r]`

```cpp
int bsearch(int l, int r)
{
    while(l < r)
    { 
        int mid = 1 + r + 1 >> 1;
        if(check(mid)) r = mid - 1;
        else l = mid;
	}
    return l;
}
```

## 练手

[AcWing 789. 数的范围](https://www.acwing.com/problem/content/791/)

把这个数组以是否满足`k <= q[i]`分为两个部分，利用模板2求出边界即可

把这个数组以是否满足`q[i] <= k`分为两个部分，利用模板1出边界即可

![image-20210711192123781](https://raw.githubusercontent.com/RainGiving/PictureBed/master/img1/20210711192123.png)



```cpp
#include <iostream>
using namespace std;
const int N = 100010;
int q[N];
int n, m;

int main()
{
    cin >> n >> m;
    for(int i = 0; i < n; ++i)	scanf("%d", &q[i]);
    while(m--)
    {
        int k;
        cin >> k;
        int l = 0, r = n - 1;
        while(l < r)
        {
            int mid = l + r >> 1; 
            if(k <= q[mid])	r = mid;
            else l = mid + 1;
        }
        if(q[l] != k) cout << -1 << ' ';
        else cout << l << ' ';
        
        l = 0, r = n - 1;
        while(l < r)
        {
            int mid = l + r + 1 >> 1;
            if(q[mid] <= k)	l = mid;
            else r = mid - 1;
        }
        if(q[l] != k) cout << -1 << endl;
        else cout << l << endl;
	}
    return 0;
}
```

# 浮点数二分

浮点数二分不存在各种边界问题，比较简单

## 模板

```cpp
bool check(double x);

double bsearch(double l, double r)
{
    const double eps = 1e-6;	//eps是精度，取决于题目要求
    while(eps < r - l)
    {
        double mid = (l + r) / 2;
        if(check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

## 练手

[AcWing 790. 数的三次方根](https://www.acwing.com/problem/content/792/)

```cpp
#include <iostream>
using namespace std;
int main()
{
    double n;
    cin >> n;
    const double eps = 1e-8;	//题目要求的是1e-6，这里定义1e-8通常够用
    double l = -10000,r = 10000;	
    //如果定义成l = 0, r = n还要特殊处理小数，负数的情况，这里直接定义成数据范围更好
    while(eps < r - l)
    {
        double mid = (l + r) / 2;
        if(n <= mid * mid * mid) r = mid;
        else l = mid;
    }
    printf("%lf", l);
    return 0;
    
}
```

注意不要有任何变量定义成了`int`，这种错误的明显提示是TLE

# 大整数相关

## 大整数加法

注意数组从左至右存放大整数的由低到高位，这样便于进位计算，输出的时候要对数组从右向左输出

```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> add(vector<int> &A, vector<int> &B) //加引用避免再拷贝一遍，提高速度
{
    vector<int> C;
    
    int t = 0;  //进位
    
    for(int i = 0; i < A.size() || i < B.size(); i++)
    {
        if(i < A.size()) t += A[i];
        if(i < B.size()) t += B[i];
        C.push_back(t % 10);    //小于10的部分存入结果
        t /= 10;    //大于等于10的部分进位到下一位
    }
    if(t) C.push_back(1);
    return C;
}

int main()
{
    string a, b;
    vector<int> A, B;
    
    cin >> a >> b;	//先作为字符串读入
    // 转换成vector
    for(int i = a.size() - 1; 0 <= i; i--) A.push_back(a[i] - '0');
    for(int i = b.size() - 1; 0 <= i; i--) B.push_back(b[i] - '0');
    
    vector<int> C = add(A, B);
    
    for(int i = C.size() - 1; 0 <= i; i--) printf("%d", C[i]);
    return 0;
    
}
```

## 大整数减法

分两种情况进行，`B <= A `时直接计算 `A - B`；否则计算 `B - A`，输出时带上负号

> 首先确定了A和B的大小关系，这样做就不存在最后一位不够减等边界情况

对于每一位，需要判断一下是否够减的问题，假设前一位的借位是`t`，则

- `0 <= A[i] - B[i] - t` 够减，`C.push_back(A[i] - B[i] - t)`
- `A[i] - B[i] - t < 0`不够减，`C.push_back(A[i] - B[i] - t + 10)`

