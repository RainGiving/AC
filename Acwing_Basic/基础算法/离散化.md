# 离散化

## 思路&模板

![image-20210823211933541](https://raw.githubusercontent.com/RainGiving/PictureBed/master/img1/20210823211933.png)

适用情况：例如题目给出一个坐标轴，它的位置范围很广，如1e9（值域大）；但是这个坐标轴上存在的有效值少,如小于等于`n`个（可以认为绝大多数是0，小部分是有用数据）；我们没办法为整个坐标轴建立数组存放各个位置的数据（会爆内存），此时，就需要离散化，将少数的分散的有效值，映射到0，1，2...（如上图）即存入一个数组

离散化方法：

1. 把所有有效的位置的坐标存到数组`alls`中去

   ```cpp
   vector<int> alls;
   for(int i = 0; i < n; i++)	//题目输入n个可能使用到的位置
   {
       cin >> x;
       alls.push_back(x);
   }
   ```

2. 将`alls`排序，去重，得到的`alls[1 ~ n]`的值是由小到大的`n`个位置的坐标，完成映射

   ```cpp
   sort(alls.begin(), alls.end());
   //unique去重且将多余的重复元素放在数组后面，返回第一个重复元素的地址；我们再用erase()删除这部分重复元素
   alls.erase(unique(alls.begin(), alls.end()), alls.end());
   ```

3. 建立一个数组`a`，`a[find(x)]`为位置坐标`x`处的值，`find(x)`返回的是坐标轴上的`x`位置在`alls`中对应的索引

   ```cpp
   int find(int x)	//二分
   {
       int l = 0, r = alls.size() - 1;
       while(l < r)
       {
           int mid = (l + r) >> 1;
           if(x <= alls[mid])	r = mid;
           else 				l = mid + 1;
   	}
       return r;	//映射 0，1，2，3...
       //return r + 1;		//映射 1，2，3，4...
       //有时为了方便find()求出的数组a求前缀和，可以返回r + 1，这样索引就从1开始
   }
   ```

## 题目&题解

